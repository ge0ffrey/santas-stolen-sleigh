== Introduction

We're solving the kaggle problem.

== How to run our code

* Open the `pom.xml` with IntelliJ or Eclipse

* Run the UI:

** Main class: `org.optaplannerdelirium.sss.app.ReindeerRoutingApp`

** VM options: `-Xmx2G -server`

** Working directory: `santas-stolen-sleigh` (the default)

** Click import button and select a dataset. Highly recommended to select a slice the first time.

* Run the Benchmarker:

** Main class: `org.optaplannerdelirium.sss.app.ReindeerRoutingBenchmarkApp`

** VM options: `-Xmx2G -server` (Add `-Dlogback.level.org.optaplanner=info` to reduce logging verbosity)

** Program arguments (optional): `ge0ffreyLaptop` to run https://github.com/ge0ffrey/santas-stolen-sleigh/blob/master/src/main/resources/org/optaplannerdelirium/sss/benchmark/ge0ffrey/ge0ffreyLaptopBenchmarkConfig.xml[another config than the default]

** Working directory: `santas-stolen-sleigh` (the default)

* Note that starting a Local Search phase on a 100k problem can include up to 1.5 hours with no output due to the nearby selection bootstrap.

== Algorithm description

We didn't have much time to implement this case.
In the first 3 weeks, we worked a few spare hours to build a simple domain.
Only during the Christmas holidays, we had enough time to start optimizing.

=== Partitioning

Once we started, we quickly realized that even simple strategies (such as 2-opt hill climbing)
would take days to flatline, so partitioning was vital. We introduced 3 strategies to partition and solve the problem:

* Whole of 100k
* 5 chunks of 20k each.
* 20 slices of 5k each.

Each of these types go in their own subdirectory of the import dir.
Because we didn't have access to a cluster, each of us ran it mostly on his laptop/desktop.
Therefore, we started by focusing on the 5 chunks, which ended up neglecting all research with the 20 slices.

We configured our https://github.com/ge0ffrey/santas-stolen-sleigh/blob/master/src/main/resources/org/optaplannerdelirium/sss/benchmark/reindeerRoutingBenchmarkConfig.xml[benchmark config]
to run the 5 chunks in parallel (with only 3 in parallel at the same time on 4 core machine).

Some time before the competition deadline,
we decided to merge the 5 chunks into a whole 100k solution and focus on optimizing that as a whole
because http://www.optaplanner.org/blog/2014/03/03/CanMapReduceSolvePlanningProblems.html[partitioning lowers solution quality].

=== Construction Heuristics

First we started with http://docs.jboss.org/optaplanner/release/latest/optaplanner-docs/html_single/#firstFitDecreasing[First Fit Decreasing]
and sorted the gifts (= the planning entities) by longitude (with more _difficult_ gifts at the right).
The initial solution created by this Construction Heuristic weren't fantastic.

To improve the initial solution, we added a https://github.com/ge0ffrey/santas-stolen-sleigh/blob/master/src/main/java/org/optaplannerdelirium/sss/solver/custom/BigGiftInitializer.java[BigGiftInitializer],
we gives all big gifts (with a weight >= 50) it's own reindeer.
The First Fit Decreasing algorithm then assigns the smaller gifts.

=== Local Search

Out of habit, we went with http://docs.jboss.org/optaplanner/release/latest/optaplanner-docs/html_single/#lateAcceptance[Late Acceptance]
as it's very easy to configure, with late acceptance size of `400` (a later benchmark showed that `100` beats it a lot in the short run).
We did quickly benchmark Tabu Search on the just initialized solutions (so again in the short run), but LA easily beat it.
This is of course no surpise in hindsight, as it didn't even flatline after days of computation, the long run wasn't hours but weeks.
We should really try Tabu Search once LA starts flatlining...
We never benchmarked Simulated Annealing (even though it's just 1 line change in the config...).

As for moves (= Local Search neigberhoods), we went with:

* http://docs.jboss.org/optaplanner/release/latest/optaplanner-docs/html_single/images/Chapter-Move_and_neighborhood_selection/changeMove.png[change moves] (= relocate)

* http://docs.jboss.org/optaplanner/release/latest/optaplanner-docs/html_single/images/Chapter-Move_and_neighborhood_selection/swapMove.png[swap moves] (= swaps)

* tail chain swap moves (= 2-opts)

* Later we also added a limited prototype for 3-opts (no reversing, and currently with a temporarily limitation that at least 2 of the gifts need to be in a different reindeer trip).

Of course, to scale these moves to a 5k VRP, let alone a 100k VRP, we needed to apply http://docs.jboss.org/optaplanner/release/latest/optaplanner-docs/html_single/#nearbySelection[nearby selection].
We originally went with a parabolic nearby distribution of `100`, but recently switched that to `200`.
This means we try connecting a gift to its nearest 100 (or 200) gifts.

Nearby is measured by the haversine distance, but we found we could use the squared direct distance too,
to get the same nearby ordering, but improving nearby bootstrap performance (from days to only 1.5 hours for the 100k problem).
Despite this, we still need to calculate the haversine distance during solving: we found that caching those wasn't really worth it
(because it exploded memory usage - you can still enable that haversine caching by adding the VM option `-Dsss.useCachingSphereLocation`).

=== Results

After days of benchmarks, each starting on the best results of the previous,
we are still not flatlining.

== Research investigations log

For team members only: Add your name to reserve a topic if you're doing it.
Summarize your findings under the topic's title.
Following the scientific method, others are encouraged to try to reproduce your findings and also report their findings below yours.

=== TS vs LA

Geoffrey:
On a 1 hour run, TS 7 was worse than LA 400 on slice0.
More importantly: TS flatlined and LA didn't flatline yet.

https://dl.dropboxusercontent.com/u/28857538/2015-12-24_102218_aggregation/index.html[Slice 2 benchmark]

=== Play with Tabu Search ratio's

Lukas:
Results here: https://drive.google.com/file/d/0B2Qb5W2kA2huVnY1eEtYZ2JvVUk/view?usp=sharing
Some conclusions:
* Performance on all slices very similar. Future benchmarks will only be done on one of the slices to save time.
* Very small (~ 1 %) tabu ratios are better than tabu size 7.
* In the long run, LA still most likely better.

=== Investigate combinations of TS and LA

Done. Results here: https://drive.google.com/file/d/0B2Qb5W2kA2huWG1PUHU3enB4djA/view?usp=sharing
To explain: this is two solvers run on the same slice, first TS, then LA. "REVERSE" results are LA first, TS second. All benchmarks have various settings to compare various nearby sizes, tabu ratios etc.

=== Play with less/more partitions

TODO

=== Play with TS parameters

TODO

=== Play with LA parameters

Ondrej:
https://drive.google.com/folderview?id=0B1PRlutaQSliT3N6RlpPS25LcEU&usp=sharing
Played with some parameters, the results seem quite interesting to me.
Please report any observations/conclusions you make so I can investigate further.

=== Play with nearby selection parameters

https://drive.google.com/file/d/0B2Qb5W2kA2huN01GN3AzNjU4VG8/view?usp=sharing
There is a lot to say about this. I'll leave everyone to draw their own conclusions for now.

=== New nearby meter alternative that ignores latitude

All gifts need to return to the north pole anyway.

Geoffrey:
In itself, it's worse than the normal meter

https://dl.dropboxusercontent.com/u/28857538/benchmarks/sss/2015-12-24_163751_aggregation_longitudeMeter/index.html[benchmark result]

=== Use subchain moves

Near the end, once we're getting stuck, we should definitely start using course-grained moves.

TODO

=== Use custom moves

==== 3-opt

TODO

==== K-opt

TODO probalby overkill

==== Ruin & recreate

TODO ge0ffrey
